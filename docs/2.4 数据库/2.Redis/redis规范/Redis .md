[TOC]

# 1、Redis简介
## 1.1 Redis特点
 1. 速度快：读取速度11W/s，写的速度8W/s。
 2. 具备原子性：Redis所有操作都是原子性，意思就是要么执行成功要么执行失败完全不执行。单个操作是原子性的，多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。
 3. 丰富的数据类型：String,List,Set,ZSet,Hash。

## 1.2 Redis与其他Key-Value缓存产品对比
 1. Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行适用。
 2. Redis不仅仅支持简单的key-value类型的数据，同时还提供list,set,zset,hash等数据结构的存储。
 3. Redis支持数据的备份，集群等高可用功能。

## 1.3 Redis优缺点
优点：
 1. 丰富的数据结构
 2. 高速读写，Redis使用自己实现的分离器，代码量很短。没有使用lock，因此效率非常高。

缺点：
 1. 持久化， Redis 直接将数据存储到内存中，要将数据保存到磁盘上，Redis 可以使用两种方式实现持久化过程，定时快照（snapshot）；每间隔一段时间将整个数据库写到磁盘上，每次均是全部数据，代价非常高，第二种方式基于语句追加（AOF）只追踪变化的数据，但是追加的log 可能过大，同时所有的操作均重新执行一遍，回复速度慢。
 2. 消耗内存，占用内存过高

# 2、Redis配置文件解读
 1. Redis默认不是以守护进程的方法运行，可以通过该配置项修改，使用yes启动守护进程。`daemonize no`
 2. 当Redis以守护进程方式运行时，Redis会默认把pid写入/var/run/redis.pid文件，通过pridfile指定。`pidfile /var/run/redis/pid`
 3. 当客户端闲置时间多长后关闭联机，如果指定为0，表示关闭该功能。`timeout 300`
 4. 指定日志记录级别：Redis支持4个级别：debug，verbose，notice，warning。默认为verbose。`loglevel berbose`
 5. 日志记录方式，默认标准输出，如果配置Redis为守护进程方式运行，而这里有配置为日志记录方式为标准输出，则日志将会发送给/dev/null。 `logfiel stdout`
 6. 设置数据库的数量，默认数据库为0，可以使用select <dbid>命令在链接指定数据库Id。`database 16`
 7. 指定多长时间内，有多少个更新操作，就会将数据同步到数据文件，可以多个条件配合。save <sconds> <changes>
   - Redis提供了三个条件：分别表示900s（15分钟）内有一个更改，300s(5分钟)内有10个更改，60s（1分钟）10000个更改。
```bash
save 900 1
save 300 10
save 60 10000
```
 8. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果未了节省CPU时间，可以关闭选项，但会导致数据库文件变得巨大。`rdbcompression yes`
 9. 指定本地数据库文件名，默认为dump.rdb `dbfilename dump.rdb`
 10. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为进程可以打开的最大文件描述数量，如果设置为`maxclients 0`表示不限制，当客户端连接达到限制时，Redis会关闭新的链接并向客户端返回`max number of clients reched`错误信息。`maxclients 128`
 11. 指定Redis最大内存限制，Redis在启动的时候会把数据加载到内存中，达到最大内存后，Redis会先清除已经到期或即将到期的Key，在此处理方法之后，仍然到达最后的内存设置，将无法进行写入操作，但仍然可以进行读取操作，Redis新的vm机制，会把Key放入内存，Value会放入swap区。`maxmemory <bytes>`
 12. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为Redis本身同步同步数据文件时，按上面save条件来进行同步的，所以一段时间内只存在内存中默认为no。`appendonly no`
 13. 指定更新日志条件，一共有3个可选值。
   - no 表示等操作系统进行数据缓存同步到磁盘（快）
   - always 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）
   - everyes 表示每秒同步一次（折中，默认值）
   - appendfsync everysec
 14. 将所有大于vm-max-memory的数据存入虚拟机内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据就是keys）也就是说，当vm-max-memory设置为0的时候，其实所有value都存在磁盘中，默认值为0.`vm-max-memory 0`
 15. Redis作为优秀的中间件缓存，时长会存储大量的数据，即使采用了集群部署来动态拓容，也应该即时的整理内存，维持系统性能（如果数据一直新增，内存则很快会占满）。两种解决方案：
   - 为数据设置超时时间：设定内存，建议不要超过1G 256-512M
   - 采用LRU算法动态不同的数据删除：内存管理的一种页面置换算法，对于在内存中，但又不用的数据块（内存块）叫做LRU，操作系统会更具哪些数据属于LRU而将其移除内存而腾出空间来加载另外的数据。
```bash
volatile-lru	设定超时时间的数据中，删除最不常用的数据
*allkeys-lru	查询所有key中最不长使用的数据进行删除，这是应用最广泛的策略
volatile-random   在已经设定了超时的数据中随机删除
allkeys-random   查询所有的key之后随机删除
volatile-ttl   查询全部设定超时时间的数据，追后马上排序，将马上将要过期的数据进行删除操作
naeviction(默认)   如果设置为属性，则不会进行删除操作，如果内存溢出则报错返回
valatile-lfu   从所有设置了国企的时间的键中驱逐使用频率最少的键
allkeys-lfu   从所有键中驱逐使用率最少的键
```
建议：了解Redis的淘汰策略之后，在平时使用尽量主动设置/更新key的expire时间，主动剔除不活跃的旧数据，有助于提升查询性能。

## 2.1 Redis常用命令
```bash
expire key seconds		为给定的key设置过期时间（以毫秒计算）
```

## 2.2 expir key seconds应用场景
 1. 限时优惠活动
 2. 网站数据缓存（对于一些需要定时更新的数据，例如：积分排行榜）
 3. 手机验证码
 4. 限制网站访客频率（例如：1分钟最多访问10次）

## 2.3 Key的命名建议
 1. 单个key最大存入数据为512M大小
 2. key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；
 3. key也不要太短，太短的话，key的可读性会降低；
 4. 在一些项目中，key最好使用统一的命名模式。例如：user:123:passwd。
 5. Key的名称需要注意区分大小写。

# 3、redis发布订阅
redis发布订阅（pub/sub）是一种消息通讯模式：发送者（pub）发送消息，订阅者（sub）接收消息。
Redis客户端可以订阅任意数量的频道。

## 3.1 命令
订阅频道：
 - SUBSCRIBE channel [channel ...]  订阅给定的一个或多个凭悼的信息
 - PSUBSCRIBE pattern [pattern ...]   订阅一个或多个富豪给定模式的频道

发布频道：
 - PUBLISH channel message   将信息发布到指定的频道

退订频道：
 - UNSUBSCRIBE [channel [channel ...]]   退订给定的频道
 - PUNSUBSCRIBE [pattern [pattern ...]]   退订素有给定模式频道

## 3.2 运用场景
 - 构建实时的消息系统，比如普通的即使聊天，群聊等功能。
 - 在一个博客网站中，有100粉丝订阅了你，当你发布新文章，就可以推送消息给粉丝们。
 - 微信公众号模式。

# 4、穿透、雪崩、热点Key
## 4.1 穿透
缓存传统指的是查询一定不存在的数据，由于缓存不命中时需要从数据库中查询，查询不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

如何处理：
持久层查询不到就缓存空结果，查询时先判断缓存是否exists(key)，如果有直接返回空，没有则查询后返回。
insert时需要清除好查询的key，否则即便DB中查询有值也查询不到。（也可设置缓存的过期时间）

## 4.2 雪崩
缓存大量失效的时候，引发大量查询数据库。

如何处理：
 - 用锁/分布式锁或者队列串行访问。
 - 缓存失效时间均匀分布。

## 4.3 热点Key
某个key的访问频率非常频繁，当key失效的时候有大量线程来构建缓存，导致复杂增加，系统崩溃。

如何处理：
 - 使用锁，单机使用sychronized。lock等，分布式系统采用分布式锁。
 - 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则进一步更新缓存。
 - 在value设置一个比过期时间t0小，过期时间t，当t1过期时候，延长t0并做更新缓存操作。
 - 设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需进一步地更新实际缓存。