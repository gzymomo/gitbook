## 数据库系统架构发展

下面我们首先了解一下数据库系统架构，最后再来看下如何解决主从同步延时的导致数据不一致。

### 主备架构

业务发展的前期，数据访问量小，这时我们可以直接采用单库的架构。

![img](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821024-1449770584.jpg)

不过我们一般不使用的上面的架构，因为存在单点的问题。若数据库出现故障，这段期间业务将会不可用。我们除了等待重启，其他没什么解决办法。

所以我们会增加一个备库，实时同步主库的数据。

![主备架构](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821262-546067713.jpg)

一旦「主库」出了故障，通过人工的方式，手动的将「主机」踢下线，将「备机」改为「主机」来继续提供服务。

这种架构，部署维护简单，业务开发也无需任何改造。

不过缺点也很明显，备库只有在主库有问题的时候才会被启用，存在一定的资源浪费的情况。

### 主从架构

随着业务发展，请求量不断变大，数据量也不断变大，业务变得更加复杂，很快数据将会到达瓶颈。

由于大多数业务都是读多写少，所以数据库读的最容易成为系统瓶颈。

这时候我们可以提高读的性能，这时我们的可以采用的方案，增加从实例，主从同步，数据读写分离。

![img](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821488-800471723.jpg)

可以看到这个架构与主备没什么区别，主要区别在于主从架构下，从库与主库一样，时刻需要干活，主库提供写服务，从库只提供读服务。

如果后续读的压力还是太大，我们还可以增加从库的数量，水平扩充读的能力。

虽然主从架构帮我们解决读的瓶颈，但是由于主从之间需要数据同步，这天然就存在一定延时。

在这延时窗口期内，从库的读只能读到一个旧数据，这也是上面案例问题的真正的原因。

![img](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083821688-426335741.jpg)

接下来我们来看下有什么办法可以优化这种情况。

## 主从延时解决办法

### 忍受大法

第一种解决办法，很简单，无他，不管他，没有读到也没事。这时业务不需要任何改造，你好，我好，她也好~

如果业务对于数据一致性要求不高，我们就可以采用这种方案。

### 数据同步写方案

主从数据同步方案，一般都是采用的异步方式同步给备库。

我们可以将其修改为同步方案，主从同步完成，主库上的写才能返回。

 ![img](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083822080-778670159.jpg)

1. 业务系统发起写操作，数据写主库
2. 写请求需要等待主从同步完成才能返回
3. 数据读从库，主从同步完成就能读到最新数据

这种方案，我们只需要修改数据库之间同步配置即可，业务层无需修改，相对简单。

**不过，由于主库写需要等待主从完成，写请求的时延将会增加，吞吐量将会降低。**

这一点对于现在在线业务，可能无法接受。

### 选择性强制读主

对于需要强一致的场景，我们可以将其的读请求都操作主库，这样**读写都在主库**，就没有不一致的情况。

![img](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083822530-453820426.jpg)

这种方案业务层需要改造一下，将其强制性读主，相对改造难度较低。

不过这种方案相对于浪费了另一个数据库，增加主库的压力。

### 中间件选择路由法

这种方案需要使用一个中间件，所有数据库操作都先发到中间件，由中间件再分发到相应的数据库。

![img](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083822784-934136814.jpg)

这时流程如下：

1. 写请求，中间件将会发到主库，同时记录一下此时写请求的 key（*操作表加主键等*）
2. 读请求，如果此时 key 存在，将会路由到主库
3. 一定时间后（*经验值*），中间件认为主从同步完成，删除这个 key，后续读将会读从库

这种方案，可以保持数据读写的一致。

但是系统架构增加了一个中间件，整体复杂度变高，业务开发也变得复杂，学习成本也比较高。

### 缓存路由大法

这种方案与中间件的方案流程比较类似，不过改造成本相对较低，不需要增加任何中间件。

![img](https://img2020.cnblogs.com/other/1419561/202012/1419561-20201209083823056-165921563.jpg)

这时流程如下:

1. 写请求发往主库，同时缓存记录操作的 key，缓存的失效时间设置为主从的延时
2. 读请求首先判断缓存是否存在
   - 若存在，代表刚发生过写操作，读请求操作主库
   - 若不存在，代表近期没发生写操作，读请求操作从库

这种方案相对中间件的方案成本较低，但是呢我们此时又引入一个缓存组件，所有读写之间就又多了一步缓存操作。