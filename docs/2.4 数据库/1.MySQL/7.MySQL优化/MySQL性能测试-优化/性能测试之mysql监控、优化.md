[TOC]

[博客园：性能测试之mysql监控、优化](https://www.cnblogs.com/xiaowenshu/p/10455309.html)



### 一、哪些东西会影响mysql的性能？

- 1.硬件
- 2.系统配置
- 3.数据库表结构
- 4.SQL以及索引

![img](https://img2018.cnblogs.com/blog/1527293/201903/1527293-20190301111807064-1158625438.png)

#### 硬件

硬件就指的是数据库服务器的配置，如果电脑的配置高，CPU处理能力强，内存大，硬盘是SSD的，那肯定性能好。

#### 系统配置

系统配置一个指的是操作系统的配置，有一些操作系统的配置会影响MYSQL的性能，现在咱们大多数服务器都是用的linux服务器，linux上面一切东西都是基于文件的，mysql数据里面的表、数据等等都是文件存在磁盘上的。

linux系统有一个系统配置是文件打开的数量，默认是1024，也就是最多只能打开1024个文件，那在数据库里面表比较多、并发大的情况下，这1024就不够用了，要想获取数据就得打开文件，但是打开文件的数量最多就1024个，就会导致有一些数据获取不到，就得等待别的文件关闭之后，才能打开。那就要修改系统的配置，在**/etc/security/limits.conf**文件里面可以修改最大打开文件的数量。

 ```bash
vi /etc/security/limits.conf

*  soft  nofile  65536
*  hard  nofile  65536
 ```



还有一些mysql配置参数会影响mysql的性能。

##### sleep超时时间

mysql的连接数是提前配置好的，如果程序里面代码写的不好，有一些数据库操作没有及时关闭数据库，那这个链接就不会释放会一直占用链接，这样子并发大的情况下，就会导致数据库连接数不够用了，就连接不上数据库了。mysql默认8小时不操作数据库才会自动关闭链接，所以这个sleep的超时时间会影响mysql的性能。

 ```mysql
set global wait_timeout=600; 设置sleep的超时间，单位是秒
show variables like '%wait_timeout%'; 查询超时时间 
 ```

##### 独立表空间设置

表空间是什么呢，就是每个表存放数据的地方。

举个例子，一个仓库，你要往仓库里面放东西的话，你来一些东西你就随便扔到里面，这样东西一多，你要找到一个东西就很难找了。那怎么办呢，我在仓库里面放几个货架，每个货架放同一个种类的东西，这样的话，找一个东西就很方便了。

表空间呢就和这个货架差不多，每个表我单独管理的话，那找数据就比较方便了。

 

**mysql5.6.6之前默认是共享的表空间，mysql5.6.6之后默认是开启了独立表空间的。**

那什么是共享表空间呢？

就是说这个空间是所有的表都共享的，所有的表的数据都存在一个地方的。

 

你想一下，所有的货架都存在一个仓库里面的话，快递员去拿货的时候，人一多，可能进出都要排队，拿货的时候就比较慢了。

所以说共享表空间如果在数据量和并发量比较大的情况下，对IO的消耗是比较大的，影响性能。

 

共享表空间还有一个缺点就是不能自动收缩，自动收缩是什么意思呢，刚建表的时候，表里面数据很少，就1条数据，可能占用空间就几kb，到后来数据多了，占用了10个G的空间，然后发现有一些数据都是垃圾数据，删了5个G，那这个时候表空间就不会自动减小了，它还是10个G，浪费空间。

 

而独立表空间就是每个表的表空间都是独享的，用仓库这个例子就是每个货架都单独在一个房间里头，这样的话快递员去拿哪个东西，直接去那个房间里就好了，不用都挤在一个仓库里了。

 

而使用了独立的表空间，每个表都有自己的表空间，删了数据也会自动收缩，就不会有上面的问题了。

 ```xml
set global innodb_file_per_table =ON; 设置独立表空间打开
show variables like '%per_table%'; #查询是否打开独立表空间 
 ```

##### 读/写进程数配置

在mysql5.5之后读、写的进程数是可以配置的。默认读和写的进程数都是4个。

当然我们都知道，人多好干活嘛。进程多就是干活的人多，具体配置根据cpu的核数和业务逻辑来配置这两个值。

假如cpu是32核的，那么就是同时可以有32个进程在运行，就可以把这两个值给调大。

假如说是系统是一个内容类的网站，大多数操作都是读操作，那么就可以把读的进程数设置大一点，写的进程数设置的小一点。

怎么修改呢，找到**mysql的配置文件，在[mysqld]节点**下加入下面参数的即可

 ```xml
innodb_read_io_threads =5 读进程数
innodb_write_io_threads =3 写进程数 
 ```

##### 缓存配置

在说缓存配置之前咱们先了解清楚，计算机在处理任务的时候是怎么处理的，先从磁盘上读取数据，然后放到内存里面，cpu去内存里面拿数据，然后处理。

在写的时候正好相反，cpu处理完之后，把数据放到内存里面，内存再放到磁盘里。

那从上面，我们发现，如果数据直接从内存里面拿的话，那速度就快很多了，我们看下面的图，读1M的数据，内存里面比从磁盘上快多少。

![img](http://www.nnzhp.cn/wp-content/uploads/2017/12/64fb85bd223d0a06de271268b08b791d.png)

 

从上面这个图我们发现从内存里面读数据比从磁盘里面取数据快了N倍。

那到mysql里面，如果取数据的时候，mysql先把一些数据缓存到内存里面的话，取数据直接从内存里面取不就快很多了。

咱们在说mysql缓存之前，先说下mysql在执行一条查询语句的时候都做了什么。

![img](http://www.nnzhp.cn/wp-content/uploads/2017/12/deaeb37da06512347300a23d31640881.png)

从上面的图我们发现，mysql是有两个地方检查了内存的。如果内存里面找到我们想要的数据，那么就不去磁盘上查询数据了。那么这两个缓存都是什么，怎么配置呢。

##### cache配置

- 缓存完整的SELECT语句和查询结果，当查询命中缓存，MySQL会立刻返回结果，跳过解析、优化和执行阶段。
- 查询缓存会跟踪系统中的每张表，如果这些表发生变化，那么和这张表相关的所有查询缓存全部失效。
- 在检查查询缓存的时候，MySQL不会对SQL进行任何处理，它精确的使用客户端传来的查询（select），只要字符大小写，或者注释有一点点不同，查询缓存就认为是不同的查询。
- 任何一个包含不确定的函数(比如now(),current_date())的查询不会被缓存。
- MySQL查询缓存可以改善性能，但是在使用的时候也有一些问题需要注意：

开启查询缓存对于读写都增加了额外的开销。对于读，在查询开始前需要先检查缓存；对于写，在写入后需要更新缓存。
一般情况这些开销相对较小，所以查询缓存一般还是有好处的。但也要根据业务特征权衡是否需要开启查询缓存。

怎么配置呢，找到**mysql的配置文件，在[mysqld]节点**下加入下面参数的即可

 ```xml
query_cache_size = 200M
分配给查询缓存的总内存，一般建议不超过256M
query_cache_limit = 1M
这个选项限制了MySQL存储的最大结果。如果查询的结果比这个大，那么就不会被缓存。
 ```

 

##### innodb_buffer_pool配置

mysql里面还有一个缓存配置就是innodb_buffer_pool的配置，innodb是现在mysql的默认存储引擎，存储引擎说白了就mysql存数据的时候到底是怎么存的。

就是一个仓库里面怎么摆放货物的。

buffer pool是innodb存储引擎带的一个缓存池，查询数据的时候，它首先会从内存中查询，如果内存中存在的话，直接返回，从而提高查询响应时间。
innodb buffer pool和cache的区别是：cacche缓存的是sql语句对应的结果集，buffer pool中缓存的是表中的数据。buffer pool一般设置为服务器物理内存的70%。

怎么配置呢，找到**mysql的配置文件，在[mysqld]节点**下加入下面参数的即可

 ```xml
innodb_buffer_pool_size=50M #Innodb_buffer_pool的大小
innodb_buffer_pool_dump_now=on #停止MySQL服务时，InnoDB将InnoDB缓冲池中的热数据保存到本地硬盘。
innodb_buffer_pool_load_at_startup =on #启动MySQL服务时，MySQL将本地热数据加载到InnoDB缓冲池中。

SHOW VARIABLES LIKE '%innodb_buffer_pool%';#查看buffer_pool的大小 
 ```

#### mysql架构上的优化

读写分离

多点写入

#### 数据库表结构优化

当然系统在设计表结构的时候，一般都是架构师和一帮开发已经把表结构设计好了，在设计表结构的时候需要注意的一些东西。

​    1、使用可以存下你的数据的最小数据类型

​    2、使用简单的数据类型，int类型和varchar类型上，mysql处理int类型更简单

​    3、尽可能的使用not null定义字段，可以为空的字段加上默认值

​      因为如果不限制not null的话，字段值是可以为空的，默认为空就是null，如果是not null的话字段值写空的话，就要写''，一个空的字符串。

​      null它在mysql里面也是要占用空间的，也不能利用索引，而空的字符串在mysql是不占用空间的，也可以利用索引。

​    4、时间类型的，用UNIX_TIMESTAMP，因为是int类型的

##### mysql索引优化

索引是什么呢，就和字典的目录一样。有目录了，那咱们查数据就快了。

最适合建索引的列是出现在where子句后面的列。

唯一索引的效果最好，因为是唯一的。

利用最左前缀。

索引并不是越多越好。

mysql索引有4种类型

1、普通索引

最普通的索引，所有列都可以加

 ```mysql
create index index_name on table_name (col);
 ```

2、主键索引

建表的时候加的主键

3、组合索引

 ```mysql
create index index_name on table_name (col,col2);
 ```

4、唯一索引

 ```mysql
CREATE UNIQUE INDEX index_name
ON table_name (column_name);
 ```

 

#####  去除重复、冗余索引

因为每个开发的水平都不一样，不可避免的的会出现一些重复索引的问题。那我们怎么来查找有一些冗余的索引呢。

就要借助percona-toolkit这个工具了，它里面有pt-duplicate-key-checker这个工具可以帮咱们找出来哪些表里面有冗余的索引，并给出修改索引的语句。

 ```xml
pt-duplicate-key-checker -uroot -pxxx -dxx#-u指的是用户 -p是密码 -d是数据库
 ```

这个能帮咱们找出来重复的索引，那还有一些根本就没有必要用的索引，虽然索引建立的并不是重复，但是实际上并没用查询语句用到它，怎么办呢，percona-toolkit这个工具里还有一个工具是pt-index-usage，它可以读取慢查询日志，帮咱们找到那些没用的索引。

 ```xml
pt-index-usage /opt/data/slow.log #后面是慢查询日志
 ```

 

#### 慢查询日志

什么是慢查询日志呢，它这个就是个神器了，对咱们测试特别有帮助，它会记录执行时间长的sql语句，这样咱们找问题的时候就比较方便了。

mysql记录的日志里面，咱们看着比较不清晰，咱们使用pt-query-digest这个工具帮咱们解析慢查询日志，它会把所有的sql的执行时间以及具体sql，执行了多少次都帮咱们统计出来。

下面是pt-query-digest的用法

 ```xml
pt-query-digest --filter='$event->{fingerprint} =~ m/^select/i' slow.log #查看包含select语句的慢查询
pt-query-digest --since=12h slow.log #最近12小时的
pt-query-digest --since '2017-12-01 09:30:00' --until '2017-12-02 10:00:00' --filter='$event->{fingerprint} =~ m/^select/i' slow.log #指定时间段
 ```



如果想实时的获取有没有执行时间长的sql，用下面这个sql语句

 ```mysql
select id,`user`,`host`,DB,command,`time`,state,info from information_schema.PROCESSLIST where TIME>=60;
 ```