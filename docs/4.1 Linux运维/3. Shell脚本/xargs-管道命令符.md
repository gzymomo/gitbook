[TOC]

[薰衣草的旋律-xargs](https://www.cnblogs.com/wangqiguo/p/6464234.html)

有时候我们的脚本却需要 echo '516' | kill 这样的效果，例如 ps -ef | grep 'ddd' | kill 这样的效果，筛选出符合某条件的进程pid然后结束。这种需求对于我们来说是理所当然而且是很常见的，那么应该怎样达到这样的效果呢。有几个解决办法：

1. 通过
```bash
kill `ps -ef | grep 'ddd'`
#这种形式，这个时候实际上等同于拼接字符串得到的命令，其效果类似于  kill $pid
```

2. for循环遍历
```bash
for procid in $(ps -aux | grep "some search" | awk '{print $2}'); do kill -9 $procid; done
#其实与第一种原理一样，只不过需要多次kill的时候是循环处理的，每次处理一个
```

3. xargs
```bash
ps -ef | grep 'ddd' | xargs kill
#xargs命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数(默认情况下是通过空格分割) 然后将参数传递给其后面的命令，作为后面命令的命令行参数
```

# 1、xargs 参数
## 1.1 -d 选项
默认情况下xargs将其标准输入中的内容以空白(包括空格、Tab、回车换行等)分割成多个之后当作命令行参数传递给其后面的命令，并运行之，我们可以使用 -d 命令指定分隔符，例如：
`echo '11@22@33' | xargs echo`
输出：
`11@22@33`
默认情况下以空白分割，那么11@22@33这个字符串中没有空白，所以实际上等价于 echo 11@22@33 其中字符串 '11@22@33' 被当作echo命令的一个命令行参数
`echo '11@22@33' | xargs -d '@' echo`
输出：
`11 22 33`
指定以@符号分割参数，所以等价于 echo 11 22 33 相当于给echo传递了3个参数，分别是11、22、33

## 1.2 -p 选项
使用该选项之后xargs并不会马上执行其后面的命令，而是输出即将要执行的完整的命令(包括命令以及传递给命令的命令行参数)，询问是否执行，输入 y 才继续执行，否则不执行。这种方式可以清楚的看到执行的命令是什么样子，也就是xargs传递给命令的参数是什么，例如：
`echo '11@22@33' | xargs -p -d '@'  echo`
输出：
```bash
echo 11 22 33
 ?...y      ==>这里询问是否执行命令 echo 11 22 33 输入y并回车，则显示执行结果，否则不执行
 11 22 33   ==>执行结果
```

## 1.3 -n 选项
该选项表示将xargs生成的命令行参数，每次传递几个参数给其后面的命令执行，例如如果xargs从标准输入中读入内容，然后以分隔符分割之后生成的命令行参数有10个，使用 -n 3 之后表示一次传递给xargs后面的命令是3个参数，因为一共有10个参数，所以要执行4次，才能将参数用完。例如：

`echo '11@22@33@44@55@66@77@88@99@00' | xargs -d '@' -n 3 echo`
输出结果：
```bash
11 22 33
44 55 66
77 88 99
00
```
等价于：
```bash
echo 11 22 33
echo 44 55 66
echo 77 88 99
echo 00
```
实际上运行了4次，每次传递3个参数，最后还剩一个，就直接传递一个参数。

## 1.4 -E 选项，有的系统的xargs版本可能是-e  eof-str
该选项指定一个字符串，当xargs解析出多个命令行参数的时候，如果搜索到-e指定的命令行参数，则只会将-e指定的命令行参数之前的参数(不包括-e指定的这个参数)传递给xargs后面的命令
`echo '11 22 33' | xargs -E '33' echo`
输出：
`11 22`

可以看到正常情况下有3个命令行参数 11、22、33 由于使用了-E '33' 表示在将命令行参数 33 之前的参数传递给执行的命令，33本身不传递。等价于 echo 11 22 这里-E实际上有搜索的作用，表示只取xargs读到的命令行参数前面的某些部分给命令执行。

注意：-E只有在xargs不指定-d的时候有效，如果指定了-d则不起作用，而不管-d指定的是什么字符，空格也不行。
```bash
echo '11 22 33' | xargs -d ' ' -E '33' echo  => 输出 11 22 33
echo '11@22@33@44@55@66@77@88@99@00 aa 33 bb' | xargs -E '33' -d '@' -p  echo  => 输出 11 22 33 44 55 66 77 88 99 00 aa 33 bb

## -0 选项表示以 '\0' 为分隔符，一般与find结合使用

find . -name "*.txt"
```

输出：
```
./2.txt
./3.txt
./1.txt     => 默认情况下find的输出结果是每条记录后面加上换行，也就是每条记录是一个新行
```

`find . -name "*.txt" -print0`
输出：
`./2.txt./3.txt./1.txt     => 加上 -print0 参数表示find输出的每条结果后面加上 '\0' 而不是换行`

`find . -name "*.txt" -print0 | xargs -0 echo`
输出：
`./2.txt ./3.txt ./1.txt`

`find . -name "*.txt" -print0 | xargs -d '\0' echo`
输出：
`./2.txt ./3.txt ./1.txt`

xargs的 -0 和 -d '\0' 表示其从标准输入中读取的内容使用 '\0' 来分割，由于 find 的结果是使用 '\0' 分隔的，所以xargs使用 '\0' 将 find的结果分隔之后得到3个参数： ./2.txt ./3.txt ./1.txt  注意中间是有空格的。上面的结果就等价于 echo ./2.txt ./3.txt ./1.txt

实际上使用xargs默认的空白分隔符也是可以的  find . -name "*.txt"  | xargs  echo   因为换行符也是xargs的默认空白符的一种。find命令如果不加-print0其搜索结果的每一条字符串后面实际上是加了换行