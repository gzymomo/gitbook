[TOC]

架构往往使用于高层级的讨论中，这类讨论一般都把“底层”实现细节排除在外。而设计，往往用来指代具体的系统底层组织结构和实现的细节。

软件架构的终极目标是：用最小的人力成本来满足构建和维护该系统的需求。

对于每个软件系统，可以通过行为和架构两个维度来体现它的实际价值。

艾森豪威尔矩阵：我有两种难题，紧急的和重要的，而紧急的难题永远是不重要的，重要的难题永远是不紧急的！
将事情进行分类，即：重要且紧急，重要不紧急，不重要但紧急，不重要且不紧急。

编程范式总览：结构化编程，面向对象编程，函数式编程。
- 结构化编程：对程序控制权的直接转移进行了限制和规范。
- 面向对象编程：对程序控制权的间接转移进行了限制和规范。
- 函数式编程：对程序中的赋值进行了限制和规范。

# 软件设计SOLID原则

SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类，以及如何将这些类链接起来成为程序。
一般情况下，我们为软件构建中层结构的主要目标如下：
- 使软件可容忍被改动。
- 使软件更容易被理解。
- 构建可在多个软件系统中复用的组件。

SRP：单一职责原则
> 一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有一个需要被改变的理由。

OCP：开闭原则
> 如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。

LSP：里式替换原则
> 如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。

ISP：接口隔离原则
> 软件设计师在设计中避免不必要的依赖。

DIP：依赖反转原则
> 高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那么实现底层细节的代码应该依赖高层策略性的代码。

## SPR-单一职责原则
任何一个软件模块都应该只对某一类行为者负责。

## OCP-开闭原则
设计良好的计算机软件应用易于扩展，同时抗拒修改。
一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。

OCP是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。

## LSP-里氏替换原则

## ISP-接口隔离原则

## DIP-依赖反转原则
如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。


将设计原则归结为以下具体的编码守则：
- 应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。-通常选用抽象工厂这个设计模式。
- 不要在具体实现类上创建衍生类。
- 不要覆盖包含具体实现的函数。
- 应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事务的名字。

设计软件建构的目的，就是为了在工作中更好地对组件进行研发、部署、运行以及维护。
> 如果想设计一个便于推进各项工作的系统，其策略就是要在设计中尽可能地保留多的可选项。

一个设计良好的软件架构必须支持以下几点：
- 系统的用例与正常运行。
- 系统的维护。
- 系统的开发。
- 系统的部署。

**架构设计的核心目标**
一个良好的架构设计应该围绕着用例来展开，这样的架构设计可以在脱离框架、工具以及使用环境的情况下完整地描述用例。
架构师应该花费很多精力确保该架构的设计在满足用例需要的情况下，尽可能地允许用户自由地选择框架。

良好的架构设计应该尽可能地允许用户推迟和延后决定采用什么框架，数据库，Web服务以及其他与环境相关的工具。

一些优良架构设计的特点包括如下几点：
- 独立于框架：这些系统的架构并不依赖某个功能丰富的框架之中的某个函数。框架可以被当成工具来使用，但不需要让系统来适应框架。
- 可被测试：这些系统的业务逻辑可以脱离UI、数据库、Web服务以及其他的外部元素来进行测试。
- 独立于UI：这些系统的UI变更起来很容易，不需要修改其他的系统部分。例如，我们可以在不修改业务逻辑的前提下将一个系统的UI由Web界面替换成命令行界面。
- 独立于数据库：可以轻易地将这些系统使用的Oracle，SQL Server替换成Mango，BigTable之类的数据库。因为业务逻辑与数据库之间完成了解耦。
- 独立于任何外部机构：这些系统的业务逻辑并不需要知道任何其他外部接口的存在。

Main组件是系统中最细节化的部分——也就是底层的策略，它是整个系统的初始点。在整个系统中，除了操作系统不会再有其他组件依赖于它了。Main组件的任务是创建所有的工厂类，策略类以及其他的全局设施，并最终将系统的控制权转交给最高抽象层的代码来处理。
Main组件中的依赖关系通常应该由依赖注入框架来注入。在该框架将依赖关系注入到Main组件之后，Main组件就应该可以在不依赖于该框架的情况下自行分配这些依赖关系了。